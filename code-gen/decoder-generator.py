import yaml
import argparse
from pathlib import Path


def generate_enum(data : dict, output_path : str) -> None:

    content : str = """
/*
 * This file is automatically generated. Do not change it
 */

#ifndef IDENTIFIERS_HPP
#define IDENTIFIERS_HPP

namespace yarvs
{

enum InstrID
{
"""
    ids = list(data.keys())
    for id in ids[:-1]:
        content += f"    k{id.upper()},\n"
    content += f"    k{ids[-1].upper()}\n"

    content += """};

} // namespace yarvs

#endif // IDENTIFIERS_HPP

"""

    with open(output_path, "w") as enum_file:
        enum_file.write(content)


def main():
    parser = argparse.ArgumentParser(
        description="Script for generating C++ code for RISC-V decoder"
    )

    parser.add_argument(
        "path",
        help="Path to YAML file generated by riscv-opcodes"
    )
    parser.add_argument(
        "--enum",
        help="Path to generated C++ header with enum containing IDs of instructions",
        required=True
    )

    args = parser.parse_args()

    if not Path.exists(Path(args.path)):
        raise Exception(f"\"{args.path}\" does not exist")
    if not Path.is_file(Path(args.path)):
        raise Exception(f"\"{args.path}\" is not a file")

    with open(args.path, "r") as yaml_file:
        data = yaml.safe_load(yaml_file)

    generate_enum(data, args.enum)


if "__main__" == __name__:
    try:
        main()
    except Exception as e:
        print(f"Caught an instance of type {type(e)}.\nwhat(): {e}")
